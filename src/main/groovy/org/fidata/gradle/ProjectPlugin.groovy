#!/usr/bin/env groovy
/*
 * org.fidata.project Gradle plugin
 * Copyright Â© 2017-2018  Basil Peace
 *
 * This file is part of gradle-base-plugins.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package org.fidata.gradle

import org.fidata.gradle.tasks.CodeNarcTaskConvention
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.file.ConfigurableFileTree
import org.gradle.api.internal.plugins.DslObject
import org.jfrog.gradle.plugin.artifactory.dsl.DoubleDelegateWrapper
import org.jfrog.gradle.plugin.artifactory.dsl.ResolverConfig

import static ProjectPluginDependencies.PLUGIN_DEPENDENCIES
import static org.gradle.language.base.plugins.LifecycleBasePlugin.CHECK_TASK_NAME
import static org.gradle.language.base.plugins.LifecycleBasePlugin.BUILD_TASK_NAME
import static org.ajoberstar.gradle.git.release.base.BaseReleasePlugin.RELEASE_TASK_NAME
import static org.gradle.api.plugins.ProjectReportsPlugin.PROJECT_REPORT
import static org.gradle.initialization.DefaultSettings.DEFAULT_BUILD_SRC_DIR
import static org.gradle.api.Project.DEFAULT_BUILD_DIR_NAME
import static org.gradle.internal.FileUtils.toSafeFileName
import static org.fidata.gradle.utils.VersionUtils.isPreReleaseVersion
import static org.gradle.language.base.plugins.LifecycleBasePlugin.VERIFICATION_GROUP
import groovy.transform.CompileStatic
import org.fidata.gradle.internal.AbstractPlugin
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.tasks.testing.Test
import org.fidata.gradle.tasks.NoJekyll
import org.fidata.gradle.tasks.ResignGitCommit
import org.gradle.buildinit.tasks.internal.TaskConfiguration
import org.gradle.api.plugins.quality.CodeNarc
import org.gradle.api.plugins.ProjectReportsPlugin
import org.gradle.api.plugins.ProjectReportsPluginConvention
import org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask
import org.gradle.api.reporting.components.ComponentReport
import org.gradle.api.tasks.diagnostics.DependencyReportTask
import org.gradle.api.tasks.diagnostics.DependencyInsightReportTask
import org.gradle.api.reporting.dependents.DependentComponentsReport
import org.gradle.api.reporting.model.ModelReport
import org.gradle.api.tasks.diagnostics.ProjectReportTask
import org.gradle.api.tasks.diagnostics.PropertyReportTask
import org.gradle.api.reporting.dependencies.HtmlDependencyReportTask
import org.gradle.api.tasks.diagnostics.TaskReportTask
import org.fidata.gradle.tasks.InputsOutputs
import org.gradle.api.artifacts.ComponentMetadataDetails
import org.gradle.api.artifacts.ComponentSelection
import org.gradle.api.file.FileTreeElement
import groovy.text.StreamingTemplateEngine
import groovy.text.Template
import org.gradle.api.logging.LogLevel
import cz.malohlava.VisTaskExecGraphPlugin
import cz.malohlava.VisTegPluginExtension
import org.gradle.api.tasks.wrapper.Wrapper
import org.gradle.api.reporting.ReportingExtension
import org.ajoberstar.gradle.git.publish.GitPublishExtension
import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask
import org.gradle.api.artifacts.ComponentSelectionRules
import org.gradle.api.artifacts.ResolutionStrategy
import de.gliderpilot.gradle.semanticrelease.UpdateGithubRelease
import org.jfrog.gradle.plugin.artifactory.dsl.ArtifactoryPluginConvention

/**
 * Provides an environment for a general, language-agnostic project
 */
@CompileStatic
final class ProjectPlugin extends AbstractPlugin {
  static final Template COMMIT_MESSAGE_TEMPLATE = new StreamingTemplateEngine().createTemplate(
    '''
      $type: $subject

      Generated by $generatedBy
    '''.stripIndent()
  )

  /**
   * List of filenames considered as license files
   */
  public static final List<String> LICENSE_FILE_NAMES = [
    // These filenames are recognized by JFrog Artifactory
    'license',
    'LICENSE',
    'license.txt',
    'LICENSE.txt',
    'LICENSE.TXT',
    // These are GPL standard file names
    'COPYING',
    'COPYING.LESSER',
  ]

  @Override
  @SuppressWarnings('CouldBeElvis')
  void apply(Project project) {
    super.apply(project)
    PLUGIN_DEPENDENCIES.findAll() { Map.Entry<String, ? extends Map> depNotation -> depNotation.value.getOrDefault('enabled', true) }.keySet().each { String id ->
      project.plugins.apply id
    }

    project.convention.plugins.put 'fidata', new ProjectConvention(project)

    project.tasks.withType(Wrapper) { Wrapper task ->
      task.with {
        group = 'Chore'
        gradleVersion = '4.8.1'
      }
    }

    if (!project.group) { project.group = 'org.fidata' }

    project.extensions.getByType(ReportingExtension).baseDir = project.convention.getPlugin(ProjectConvention).reportsDir

    configureLifecycle()

    configureBuildToolsLifecycle()

    configureDependencyResolution()

    configureArtifactory()

    configureSigning()

    configureGit()

    configureSemanticRelease()

    configureGitPublish()

    configureCodeNarc()

    configureDiagnostics()
  }

  /**
   * Name of lint task
   */
  public static final String LINT_TASK_NAME = 'lint'

  private void configureLifecycle() {
    project.tasks.getByName(BUILD_TASK_NAME).dependsOn.remove CHECK_TASK_NAME
    project.tasks.getByName(RELEASE_TASK_NAME).with {
      // dependsOn BUILD_TASK_NAME TOTEST
      dependsOn project.tasks.getByName(CHECK_TASK_NAME)
      if (project.convention.getPlugin(ProjectConvention).isRelease) {
        dependsOn project.tasks.getByName(/*GitPublishPlugin.PUSH_TASK*/'gitPublishPush')
      }
    }
    Task lintTask = project.tasks.create(LINT_TASK_NAME) { Task task ->
      task.with {
        group = VERIFICATION_GROUP
        description = 'Runs all static code analyses'
      }
    }
    project.tasks.getByName(CHECK_TASK_NAME).dependsOn lintTask
    project.tasks.withType(Test) { Test task ->
      task.project.tasks.getByName(CHECK_TASK_NAME).dependsOn task
    }
  }

  /**
   * Name of buildToolsInstall task
   */
  public static final String BUILD_TOOLS_INSTALL_TASK_NAME = 'buildToolsInstall'
  /**
   * Name of buildToolsUpdate task
   */
  public static final String BUILD_TOOLS_UPDATE_TASK_NAME = 'buildToolsUpdate'
  /**
   * Name of buildToolsOutdated task
   */
  public static final String BUILD_TOOLS_OUTDATED_TASK_NAME = 'buildToolsOutdated'
  /**
   * Name of resolveAndLockAll task
   */
  public static final String RESOLVE_AND_LOCK_ALL_TASK_NAME = 'resolveAndLockAll'

  @SuppressWarnings('BracesForForLoop')
  private void configureBuildToolsLifecycle() {
    Task buildToolsInstall = project.tasks.create(BUILD_TOOLS_INSTALL_TASK_NAME) { Task task ->
      task.with {
        group = TaskConfiguration.GROUP
        description = 'Install all buildTools for build'
      }
    }
    Task buildToolsUpdate = project.tasks.create(BUILD_TOOLS_UPDATE_TASK_NAME) { Task task ->
      task.with {
        group = TaskConfiguration.GROUP
        description = 'Update all buildTools that support automatic update'
        mustRunAfter buildToolsInstall
      }
    }
    Task buildToolsOutdated = project.tasks.create(BUILD_TOOLS_OUTDATED_TASK_NAME) { Task task ->
      task.with {
        group = TaskConfiguration.GROUP
        description = 'Show outdated buildTools'
        mustRunAfter buildToolsInstall
      }
    }
    project.afterEvaluate {
      for (Task task in
        project.tasks
        - buildToolsInstall
        - buildToolsInstall.taskDependencies.getDependencies(buildToolsInstall)
        - buildToolsInstall.mustRunAfter.getDependencies(buildToolsInstall)
        - buildToolsInstall.shouldRunAfter.getDependencies(buildToolsInstall)
      ) {
        task.mustRunAfter buildToolsInstall
      }
      for (Task task in
        project.tasks
        - buildToolsUpdate
        - buildToolsUpdate.taskDependencies.getDependencies(buildToolsUpdate)
        - buildToolsUpdate.mustRunAfter.getDependencies(buildToolsUpdate)
        - buildToolsUpdate.shouldRunAfter.getDependencies(buildToolsUpdate)
      ) {
        task.mustRunAfter buildToolsUpdate
      }

      project.dependencyLocking.lockAllConfigurations()

      Task resolveAndLockAll = project.tasks.create(RESOLVE_AND_LOCK_ALL_TASK_NAME) { Task task ->
        task.with {
          doFirst {
              assert project.gradle.startParameter.writeDependencyLocks
          }
          doLast {
            project.configurations.each {
              if (it.canBeResolved) {
                it.resolve()
              }
            }
          }
        }
      }
      buildToolsUpdate.dependsOn resolveAndLockAll

      project.tasks.withType(DependencyUpdatesTask) { DependencyUpdatesTask task ->
        task.group = 'Chore'
        buildToolsOutdated.dependsOn task
      }
    }
  }

  private void configureDependencyResolution() {
    project.dependencies.components.all { ComponentMetadataDetails details ->
      if (details.status == 'release' && isPreReleaseVersion(details.id.version)) {
        details.status = 'milestone'
      }
    }

    project.tasks.withType(DependencyUpdatesTask) { DependencyUpdatesTask task ->
      task.with {
        revision = 'release'
        outputFormatter = 'xml'
        outputDir = new File(project.convention.getPlugin(ProjectConvention).xmlReportsDir, 'dependencyUpdates').toString()
        resolutionStrategy = { ResolutionStrategy resolutionStrategy ->
          resolutionStrategy.componentSelection { ComponentSelectionRules rules ->
            rules.all { ComponentSelection selection ->
              if (revision == 'release' && isPreReleaseVersion(selection.candidate.version)) {
                selection.reject 'Pre-release version'
              }
            }
          }
        }
      }
    }
  }

  /**
   * URL of FIDATA Artifactory
   */
  public static final String ARTIFACTORY_URL = 'https://fidata.jfrog.io/fidata'

  private void configureArtifactory() {
    if (project.hasProperty('artifactoryUser') && project.hasProperty('artifactoryPassword')) {
      String repository = project.convention.getPlugin(ProjectConvention).isRelease ? 'libs-release' : 'libs-snapshot'
      project.convention.getPlugin(ArtifactoryPluginConvention).with {
        contextUrl = ARTIFACTORY_URL
        clientConfig.resolver.repoKey = repository
        clientConfig.resolver.username = project.property('artifactoryUser')
        clientConfig.resolver.password = project.property('artifactoryPassword')
        clientConfig.resolver.maven = true
      }
    }
  }

  private void configureSigning() {
    System.setProperty 'signing.keyId', project.property('gpgKeyId').toString()
    System.setProperty 'signing.secretKeyRingFile', project.property('gpgSecretKeyRingFile').toString()
  }

  private void configureGit() {
    if (project.hasProperty('gitUsername') && project.property('gitPassword')) {
      System.setProperty 'org.ajoberstar.grgit.auth.username', project.property('gitUsername').toString()
      System.setProperty 'org.ajoberstar.grgit.auth.password', project.property('gitPassword').toString()
    }
  }

  private void configureSemanticRelease() {
    if (project.hasProperty('ghToken')) {
      /*project.extensions.getByType(SemanticReleasePluginExtension.class)*/ // TODO
      project.tasks.withType(UpdateGithubRelease).getByName('updateGithubRelease').repo.ghToken = project.property('ghToken').toString()
    }
  }

  /**
   * Name of NoJekyll task
   */
  public static final String NO_JEKYLL_TASK_NAME = 'noJekyll'

  private void configureGitPublish() {
    project.extensions.getByType(GitPublishExtension).with {
      branch.set 'gh-pages'
      preserve.include '**'
      preserve.exclude '*-SNAPSHOT/**' // TODO - keep other branches ?
      commitMessage.set COMMIT_MESSAGE_TEMPLATE.make(
        type: 'docs',
        subject: "publish documentation for version ${ project.version }",
        generatedBy: 'org.ajoberstar:gradle-git-publish'
      ).toString()
    }

    NoJekyll noJekyllTask = project.tasks.create(NO_JEKYLL_TASK_NAME, NoJekyll) { NoJekyll task ->
      task.with {
        description = 'Generates .nojekyll file in gitPublish repository'
        destinationDir = project.extensions.getByType(GitPublishExtension).repoDir.asFile.get()
      }
    }
    project.tasks.getByName(/* WORKAROUND: GitPublishPlugin.COMMIT_TASK has package scope <grv87 2018-06-23> */ 'gitPublishCommit').dependsOn noJekyllTask

    /*
     * WORKAROUND:
     * JGit doesn't support signed commits yet.
     * See https://bugs.eclipse.org/bugs/show_bug.cgi?id=382212
     * <grv87 2018-06-22>
     */
    ResignGitCommit resignGitCommit = project.tasks.create("${ /*GitPublishPlugin.COMMIT_TASK*/ 'gitPublishCommit' }Resign", ResignGitCommit) { ResignGitCommit task ->
      task.description = 'Amend git publish commit adding sign to it'
    }
    project.tasks.getByName(/* WORKAROUND: GitPublishPlugin.COMMIT_TASK has package scope <grv87 2018-06-23> */ 'gitPublishCommit').finalizedBy resignGitCommit
  }

  /**
   * Name of CodeNarc common task
   */
  public static final String CODENARC_TASK_NAME = 'codenarc'

  private void configureCodeNarc() {
    Task codeNarcTask = project.tasks.create(CODENARC_TASK_NAME) { Task task ->
      task.with {
        group = 'Verification'
        description = 'Runs CodeNarc analysis for each source set'
      }
    }
    project.tasks.getByName(LINT_TASK_NAME).dependsOn codeNarcTask

    project.tasks.withType(CodeNarc) { CodeNarc task ->
      new DslObject(task).convention.plugins.put 'disabledRules', new CodeNarcTaskConvention(task)

      task.with {
        String reportFileName = "codenarc/${ toSafeFileName((name - ~/^codenarc/ /* WORKAROUND: CodeNarcPlugin.getTaskBaseName has protected scope <grv87 2018-06-23> */).uncapitalize()) }"
        reports.xml.enabled = true
        reports.xml.setDestination new File(project.convention.getPlugin(ProjectConvention).xmlReportsDir, "${ reportFileName }.xml")
        // reports.console.enabled = true // TODO
        reports.html.enabled = true
        reports.html.setDestination new File(project.convention.getPlugin(ProjectConvention).htmlReportsDir, "${ reportFileName }.html")
      }
      codeNarcTask.dependsOn task
    }

    project.tasks.create(/* CodeNarcPlugin.getTaskBaseName() */ "codenarc${ DEFAULT_BUILD_SRC_DIR.capitalize() }", CodeNarc) { CodeNarc task ->
      Closure excludeBuildDir = { FileTreeElement fte ->
        String[] p = fte.relativePath.segments
        int i = 0
        while (i < p.length && p[i] == DEFAULT_BUILD_SRC_DIR) { i++ }
        i < p.length && p[i] == DEFAULT_BUILD_DIR_NAME
      }
      task.with {
        for (File f in project.fileTree(project.projectDir) { ConfigurableFileTree fileTree ->
          fileTree.include '**/*.gradle'
          fileTree.exclude excludeBuildDir
        }) {
          source f
        }
        for (File f in project.fileTree(DEFAULT_BUILD_SRC_DIR) { ConfigurableFileTree fileTree ->
          fileTree.include '**/*.groovy'
          fileTree.exclude excludeBuildDir
        }) {
          source f
        }
        source 'Jenkinsfile'
        source project.fileTree(dir: project.file('config'), includes: ['**/*.groovy'])
      }
    }
  }

  /**
   * Name of Diagnostics task group
   */
  public static final String DIAGNOSTICS_TASK_GROUP_NAME = 'Diagnostics'

  /**
   * Name of InputsOutputs task
   */
  public static final String INPUTS_OUTPUTS_TASK_NAME = 'inputsOutputs'

  private void configureDiagnostics() {
    project.plugins.withType(ProjectReportsPlugin) {
      project.convention.getPlugin(ProjectReportsPluginConvention).projectReportDirName = project.convention.getPlugin(ProjectConvention).reportsDir.toPath().relativize(new File(project.convention.getPlugin(ProjectConvention).txtReportsDir, 'project').toPath()).toString()

      project.tasks.withType(BuildEnvironmentReportTask) { BuildEnvironmentReportTask task ->
        task.group = DIAGNOSTICS_TASK_GROUP_NAME
      }
      project.tasks.withType(ComponentReport) { ComponentReport task ->
        task.group = DIAGNOSTICS_TASK_GROUP_NAME
      }
      project.tasks.withType(DependencyReportTask) { DependencyReportTask task ->
        task.group = DIAGNOSTICS_TASK_GROUP_NAME
      }
      project.tasks.withType(DependencyInsightReportTask) { DependencyInsightReportTask task ->
        task.group = DIAGNOSTICS_TASK_GROUP_NAME
      }
      project.tasks.withType(DependentComponentsReport) { DependentComponentsReport task ->
        task.group = DIAGNOSTICS_TASK_GROUP_NAME
      }
      project.tasks.withType(ModelReport) { ModelReport task ->
        task.group = DIAGNOSTICS_TASK_GROUP_NAME
      }
      project.tasks.withType(ProjectReportTask) { ProjectReportTask task ->
        task.group = DIAGNOSTICS_TASK_GROUP_NAME
      }
      project.tasks.withType(PropertyReportTask) { PropertyReportTask task ->
        task.group = DIAGNOSTICS_TASK_GROUP_NAME
      }
      project.tasks.withType(HtmlDependencyReportTask) { HtmlDependencyReportTask task ->
        task.with {
          group = DIAGNOSTICS_TASK_GROUP_NAME
          reports.html.setDestination new File(project.convention.getPlugin(ProjectConvention).htmlReportsDir, 'dependencies')
        }
      }
      project.tasks.withType(TaskReportTask) { TaskReportTask task ->
        task.group = DIAGNOSTICS_TASK_GROUP_NAME
      }
      project.tasks.getByName(PROJECT_REPORT).group = DIAGNOSTICS_TASK_GROUP_NAME
    }

    project.tasks.create(INPUTS_OUTPUTS_TASK_NAME, InputsOutputs) { InputsOutputs task ->
      task.with {
        group = DIAGNOSTICS_TASK_GROUP_NAME
        description = 'Generates report about all task file inputs and outputs'
        outputFile = new File(project.convention.getPlugin(ProjectConvention).txtReportsDir, InputsOutputs.DEFAULT_OUTPUT_FILE_NAME)
      }
    }

    project.plugins.withType(VisTaskExecGraphPlugin) {
      project.extensions.getByType(VisTegPluginExtension).with {
        enabled        = (project.logging.level ?: project.gradle.startParameter.logLevel) <= LogLevel.INFO
        colouredNodes  = true
        colouredEdges  = true
        destination    = new File(project.convention.getPlugin(ProjectConvention).reportsDir, 'visteg.dot').toString()
        exporter       = 'dot'
        colorscheme    = 'paired12'
        nodeShape      = 'box'
        startNodeShape = 'hexagon'
        endNodeShape   = 'doubleoctagon'
      }
    }
  }
}
