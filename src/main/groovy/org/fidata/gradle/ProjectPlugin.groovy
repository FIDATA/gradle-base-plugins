#!/usr/bin/env groovy
/*
 * org.fidata.project Gradle plugin
 * Copyright Â© 2017  Basil Peace
 *
 * This file is part of gradle-base-plugins.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package org.fidata.gradle

import static org.gradle.internal.FileUtils.toSafeFileName
import groovy.transform.CompileStatic
import groovy.transform.CompileDynamic
import org.fidata.gradle.internal.AbstractPlugin
import org.gradle.api.Project
import org.gradle.initialization.DefaultSettings
import org.gradle.language.base.plugins.LifecycleBasePlugin
import nebula.plugin.dependencylock.DependencyLockTaskConfigurer
import org.ajoberstar.gradle.git.release.base.BaseReleasePlugin
import org.ajoberstar.gradle.git.publish.GitPublishPlugin
import org.gradle.api.plugins.ProjectReportsPlugin
import org.gradle.api.Task
import nebula.plugin.dependencylock.tasks.GenerateLockTask
import nebula.plugin.dependencylock.tasks.UpdateLockTask
import nebula.plugin.dependencylock.tasks.SaveLockTask
import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask
import org.gradle.api.tasks.testing.Test
import de.gliderpilot.gradle.semanticrelease.SemanticReleasePluginExtension
import org.fidata.gradle.tasks.NoJekyll
import org.fidata.gradle.tasks.ResignGitCommit
import org.gradle.api.plugins.quality.CodeNarc
import org.gradle.api.plugins.ProjectReportsPluginConvention
import org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask
import org.gradle.api.reporting.components.ComponentReport
import org.gradle.api.tasks.diagnostics.DependencyReportTask
import org.gradle.api.tasks.diagnostics.DependencyInsightReportTask
import org.gradle.api.reporting.dependents.DependentComponentsReport
import org.gradle.api.reporting.model.ModelReport
import org.gradle.api.tasks.diagnostics.ProjectReportTask
import org.gradle.api.tasks.diagnostics.PropertyReportTask
import org.gradle.api.reporting.dependencies.HtmlDependencyReportTask
import org.gradle.api.tasks.diagnostics.TaskReportTask
import org.fidata.gradle.tasks.InputsOutputs
import org.gradle.api.artifacts.ComponentMetadataDetails
import org.gradle.api.artifacts.ComponentSelection
import org.gradle.api.file.FileTreeElement
import groovy.text.StreamingTemplateEngine
import groovy.text.Template
import com.google.common.io.Resources
import com.google.common.base.Charsets
import org.gradle.api.logging.LogLevel
import org.fidata.gradle.ProjectPluginDependencies
import cz.malohlava.VisTegPluginExtension
import org.gradle.plugins.ide.eclipse.model.EclipseModel
import org.gradle.api.tasks.wrapper.Wrapper

/**
 * Provides an environment for a general, language-agnostic project
 */
@CompileStatic
final class ProjectPlugin extends AbstractPlugin {
  static final Template COMMIT_MESSAGE_TEMPLATE = new StreamingTemplateEngine().createTemplate(
    '''
      $type: $subject

      Generated by $generatedBy
    '''.stripIndent()
  )

  /**
   * List of filenames considered as license files
   */
  public static final List<String> LICENSE_FILE_NAMES = [
    // These filenames are recognized by JFrog Artifactory
    'license',
    'LICENSE',
    'license.txt',
    'LICENSE.txt',
    'LICENSE.TXT',
    // These are GPL standard file names
    'COPYING',
    'COPYING.LESSER',
  ]

  @Override
  @SuppressWarnings('CouldBeElvis')
  void apply(Project project) {
    super.apply(project)
    project.with {
      ProjectPluginDependencies.PLUGIN_DEPENDENCIES.findAll() { Map.Entry<String, ? extends Map> depNotation -> depNotation.value.getOrDefault('enabled', true) }.keySet().each { String id ->
        plugins.apply id
      }

      ProjectConvention projectConvention = new ProjectConvention(project)
      convention.plugins.put 'fidata', projectConvention

      tasks.withType(Wrapper) { Wrapper task ->
        task.with {
          group = 'Chore'
          gradleVersion = '4.3.1'
        }
      }

      if (!group) { group = 'org.fidata' }

      reporting.baseDir reportsDir
    }

    configureLifecycle()

    configurePrerequisitesLifecycle()

    configureDependencyResolution()

    configureArtifactory()

    configureSigning()

    configureGit()

    configureSemanticRelease()

    configureGitPublish()

    configureCodeNarc()

    configureDiagnostics()

    project.getExtensions().getByType(EclipseModel).classpath.with {
      downloadSources = true
      downloadJavadoc = true
    }
  }

  /**
   * Name of lint task
   */
  public static final String LINT_TASK_NAME = 'lint'

  private void configureLifecycle() {
    project.with {
      tasks.getByName('LifecycleBasePlugin.BUILD_TASK_NAME').dependsOn.remove LifecycleBasePlugin.CHECK_TASK_NAME
      tasks.getByName('BaseReleasePlugin.RELEASE_TASK_NAME').with {
        // dependsOn LifecycleBasePlugin.BUILD_TASK_NAME TOTEST
        dependsOn tasks.getByName('LifecycleBasePlugin.CHECK_TASK_NAME')
        if (isRelease) {
          dependsOn tasks.getByName('GitPublishPlugin.PUSH_TASK')
        }
      }
      Task lintTask = task(LINT_TASK_NAME) {
        group = 'Verification'
        description = 'Runs all static code analyses'
      }
      tasks.getByName('LifecycleBasePlugin.CHECK_TASK_NAME').dependsOn lintTask
      tasks.withType(Test) { Test task ->
        task.project.tasks.getByName('LifecycleBasePlugin.CHECK_TASK_NAME').dependsOn task
      }
    }
  }

  /**
   * Name of prerequisitesInstall task
   */
  public static final String PREREQUISITES_INSTALL_TASK_NAME = 'prerequisitesInstall'
  /**
   * Name of prerequisitesUpdate task
   */
  public static final String PREREQUISITES_UPDATE_TASK_NAME = 'prerequisitesUpdate'
  /**
   * Name of prerequisitesOutdated task
   */
  public static final String PREREQUISITES_OUTDATED_TASK_NAME = 'prerequisitesOutdated'

  @SuppressWarnings('BracesForForLoop')
  private void configurePrerequisitesLifecycle() {
    project.with {
      Task prerequisitesInstall = task(PREREQUISITES_INSTALL_TASK_NAME) { Task task ->
        task.with {
          group = 'Chore'
          description = 'Install all prerequisites for build'
        }
      }
      Task prerequisitesUpdate = task(PREREQUISITES_UPDATE_TASK_NAME) { Task task ->
        task.with {
          group = 'Chore'
          description = 'Update all prerequisites that support automatic update'
          mustRunAfter prerequisitesInstall
        }
      }
      Task prerequisitesOutdated = task(PREREQUISITES_OUTDATED_TASK_NAME) { Task task ->
        task.with {
          group = 'Chore'
          description = 'Show outdated prerequisites'
          mustRunAfter prerequisitesInstall
        }
      }
      afterEvaluate {
        for (Task task in
          tasks
          - prerequisitesInstall
          - prerequisitesInstall.taskDependencies.getDependencies(prerequisitesInstall)
          - prerequisitesInstall.mustRunAfter.getDependencies(prerequisitesInstall)
          - prerequisitesInstall.shouldRunAfter.getDependencies(prerequisitesInstall)
        ) {
          task.mustRunAfter prerequisitesInstall
        }
        for (Task task in
            tasks
            - prerequisitesUpdate
            - prerequisitesUpdate.taskDependencies.getDependencies(prerequisitesUpdate)
            - prerequisitesUpdate.mustRunAfter.getDependencies(prerequisitesUpdate)
            - prerequisitesUpdate.shouldRunAfter.getDependencies(prerequisitesUpdate)
        ) {
          task.mustRunAfter prerequisitesUpdate
        }
      }

      tasks.withType(GenerateLockTask) { GenerateLockTask task ->
        task.group = null
        prerequisitesInstall.mustRunAfter task
      }
      tasks.withType(UpdateLockTask) { UpdateLockTask task ->
        task.group = 'Chore'
        prerequisitesUpdate.mustRunAfter task
      }
      tasks.withType(SaveLockTask) { SaveLockTask task ->
        task.group = 'Chore'
        prerequisitesUpdate.mustRunAfter task
      }
      tasks.findByName('saveGlobalLock')?.with {
        dependsOn tasks[DependencyLockTaskConfigurer.UPDATE_GLOBAL_LOCK_TASK_NAME]
      }
      tasks.getByName('saveLock').with {
        dependsOn tasks[DependencyLockTaskConfigurer.UPDATE_LOCK_TASK_NAME]
      }
      prerequisitesUpdate.with {
        if (tasks.withType(SaveLockTask).findByName('saveGlobalLock')?.outputLock?.exists()) {
          dependsOn tasks['saveGlobalLock']
        }
        else {
          dependsOn tasks['saveLock']
        }
      }

      tasks.withType(DependencyUpdatesTask) { DependencyUpdatesTask task ->
        task.group = 'Chore'
        prerequisitesOutdated.dependsOn task
      }
    }
  }

  private void configureDependencyResolution() {
    project.with {
      dependencyLock.includeTransitives = true

      dependencies.components.all { ComponentMetadataDetails details ->
        if (details.status == 'release') {
          boolean isPreRelease
          try {
            isPreRelease = convention.getByType(ProjectConvention).isPreReleaseVersion(details.id.version)
          }
          catch(Exception) {
            logger.warn sprintf('Error determining whether \'%s\' is pre-release version', [details.id.version])
          }
          if (isPreRelease) {
            details.status = 'milestone'
          }
        }
      }

      dependencyUpdates {
        revision = 'release'
        outputFormatter = 'xml'
        outputDir = new File(convention.getByType(ProjectConvention).xmlReportsDir, 'dependencyUpdates')
        resolutionStrategy = {
          componentSelection.all { ComponentSelection selection ->
            if (revision == 'release') {
              boolean isPreRelease
              try {
                isPreRelease = convention.getByType(ProjectConvention).isPreReleaseVersion(selection.candidate.version)
              }
              catch(Exception) {
                logger.warn sprintf('Error determining whether \'%s\' is pre-release version', [details.id.version])
              }
              if (isPreRelease) {
                selection.reject 'Pre-release version'
              }
            }
          }
        }
      }
    }
  }

  /**
   * URL of FIDATA Artifactory
   */
  public static final String ARTIFACTORY_URL = 'https://fidata.jfrog.io/fidata'

  /*
   * CAVEAT:
   * Conventions and extensions in JFrog Gradle plugins have package scopes,
   * so we can't use static compilation
   * <grv87 2018-02-18>
   */
  @CompileDynamic
  private void configureArtifactory() {
    project.with {
      if (project.hasProperty('artifactoryUser') && project.hasProperty('artifactoryPassword')) {
        artifactory {
          contextUrl = ARTIFACTORY_URL
          resolve {
            repository {
              repoKey = isRelease ? 'libs-release' : 'libs-snapshot'
              username = project.getProperty('artifactoryUser')
              password = project.getProperty('artifactoryPassword')
              maven = true
            }
          }
        }
      }
      else {
        repositories {
          jcenter()
          mavenCentral()
        }
      }
    }
  }

  private void configureSigning() {
    System.setProperty 'signing.keyId', project.getProperty('gpgKeyId').toString()
    System.setProperty 'signing.password', project.getProperty('gpgKeyPassword').toString()
    System.setProperty 'signing.secretKeyRingFile', project.getProperty('gpgSecretKeyRingFile').toString()
  }

  private void configureGit() {
    if (project.hasProperty('gitUsername') && project.hasProperty('gitPassword')) {
      System.setProperty 'org.ajoberstar.grgit.auth.username', project.getProperty('gitUsername').toString()
      System.setProperty 'org.ajoberstar.grgit.auth.password', project.getProperty('gitPassword').toString()
    }
  }

  private void configureSemanticRelease() {
    if (project.hasProperty('ghToken')) {
      project.extensions.getByType(SemanticReleasePluginExtension.class).repo.ghToken = project.getProperty('ghToken').toString()
    }
  }

  /**
   * Name of NoJekyll task
   */
  public static final String NO_JEKYLL_TASK_NAME = 'noJekyll'

  private void configureGitPublish() {
    project.with {
      gitPublish {
        branch = 'gh-pages'
        preserve {
          include '**'
          exclude '*-SNAPSHOT/**'
        }
        commitMessage = COMMIT_MESSAGE_TEMPLATE.make(
          type: 'docs',
          subject: "publish documentation for version $version",
          generatedBy: 'org.ajoberstar:gradle-git-publish'
        )
      }

      NoJekyll noJekyllTask = task(NO_JEKYLL_TASK_NAME, type: NoJekyll) {
        description = 'Generates .nojekyll file in gitPublish repository'
        destinationDir = gitPublish.repoDir
      }
      tasks.getByName(GitPublishPlugin.COMMIT_TASK).dependsOn noJekyllTask

      /*
       * BLOCKED:
       * JGit doesn't support signed commits yet.
       * See https://bugs.eclipse.org/bugs/show_bug.cgi?id=382212 <>
       */
      ResignGitCommit resignGitCommit = task("${ GitPublishPlugin.COMMIT_TASK }Resign", type: ResignGitCommit) {
        description = 'Amend git publish commit adding sign to it'
      }
      tasks.getByName(GitPublishPlugin.COMMIT_TASK).finalizedBy resignGitCommit
    }
  }

  /**
   * Name of CodeNarc common task
   */
  public static final String CODENARC_TASK_NAME = 'codenarc'

  private static final String CODENARC_DEFAULT_CONFIG = Resources.toString(Resources.getResource(ProjectPlugin, 'config/codenarc/codenarc.groovy'), Charsets.UTF_8)

  private static final Template CODENARC_DISABLED_RULES_CONFIG_TEMPLATE = new StreamingTemplateEngine().createTemplate(Resources.toString(Resources.getResource(ProjectPlugin, 'config/codenarc/codenarc.disabledRules.groovy.template'), Charsets.UTF_8))

  private void configureCodeNarc() {
    project.with {
      Task codeNarcTask = task(CODENARC_TASK_NAME) { Task task ->
        task.with {
          group = 'Verification'
          description = 'Runs CodeNarc analysis for each source set'
        }
      }
      tasks.getByName(LINT_TASK_NAME).dependsOn codeNarcTask

      tasks.withType(CodeNarc) { CodeNarc task ->
        task.with {
          config = project.resources.text.fromString(CODENARC_DEFAULT_CONFIG)
          doFirst {
            if (task.hasProperty('disabledRules')) {
              config = project.resources.text.fromString(
                config.asString() +
                CODENARC_DISABLED_RULES_CONFIG_TEMPLATE.make(disabledRules: task.getProperty('disabledRules').inspect())
              )
            }
          }
          String reportFileName = "codenarc/${ toSafeFileName((name - ~/^codenarc/).uncapitalize()) }"
          reports {
            xml {
              enabled = true
              destination = new File(project.convention.getPlugin(ProjectReportsPluginConvention).xmlReportsDir, "${ reportFileName }.xml")
            }
            console.enabled = true
            html {
              enabled = true
              destination = new File(project.convention.getPlugin(ProjectReportsPluginConvention).htmlReportsDir, "${ reportFileName }.html")
            }
          }
        }
        codeNarcTask.dependsOn task
      }

      task("codenarc${ DefaultSettings.DEFAULT_BUILD_SRC_DIR.capitalize() }", type: CodeNarc) { CodeNarc task ->
        Closure excludeBuildDir = { FileTreeElement fte ->
          String[] p = fte.relativePath.segments
          int i = 0
          while (i < p.length && p[i] == DefaultSettings.DEFAULT_BUILD_SRC_DIR) { i++ }
          i < p.length && p[i] == Project.DEFAULT_BUILD_DIR_NAME
        }
        task.with {
          for (File f in fileTree(projectDir) {
            include '**/*.gradle'
            exclude excludeBuildDir
          }) {
            source f
          }
          for (File f in fileTree(DefaultSettings.DEFAULT_BUILD_SRC_DIR) {
            include '**/*.groovy'
            exclude excludeBuildDir
          }) {
            source f
          }
          source 'Jenkinsfile'
          source fileTree(dir: file('config'), includes: ['**/*.groovy'])
        }
      }
    }
  }

  /**
   * Name of InputsOutputs task
   */
  public static final String INPUTS_OUTPUTS_TASK_NAME = 'inputsOutputs'

  private void configureDiagnostics() {
    project.with {
      convention.getPlugin(ProjectReportsPluginConvention).projectReportDirName = convention.getPlugin(ProjectConvention).reportsDir.toPath().relativize(new File(convention.getPlugin(ProjectConvention).txtReportsDir, 'project').toPath()).toString()

      tasks.withType(BuildEnvironmentReportTask) { BuildEnvironmentReportTask task ->
        task.group = 'Diagnostics'
      }
      tasks.withType(ComponentReport) { ComponentReport task ->
        task.group = 'Diagnostics'
      }
      tasks.withType(DependencyReportTask) { DependencyReportTask task ->
        task.group = 'Diagnostics'
      }
      tasks.withType(DependencyInsightReportTask) { DependencyInsightReportTask task ->
        task.group = 'Diagnostics'
      }
      tasks.withType(DependentComponentsReport) { DependentComponentsReport task ->
        task.group = 'Diagnostics'
      }
      tasks.withType(ModelReport) { ModelReport task ->
        task.group = 'Diagnostics'
      }
      tasks.withType(ProjectReportTask) { ProjectReportTask task ->
        task.group = 'Diagnostics'
      }
      tasks.withType(PropertyReportTask) { PropertyReportTask task ->
        task.group = 'Diagnostics'
      }
      tasks.withType(HtmlDependencyReportTask) { HtmlDependencyReportTask task ->
        task.with {
          group = 'Diagnostics'
          reports.html.destination = new File(convention.getPlugin(ProjectConvention).htmlReportsDir, 'dependencies')
        }
      }
      tasks.withType(TaskReportTask) { TaskReportTask task ->
        task.group = 'Diagnostics'
      }
      tasks.getByName(ProjectReportsPlugin.PROJECT_REPORT).group = 'Diagnostics'

      task(INPUTS_OUTPUTS_TASK_NAME, type: InputsOutputs) {
        group = 'Diagnostics'
        description = 'Generates report about all task file inputs and outputs'
        outputFile = new File(convention.getPlugin(ProjectConvention).txtReportsDir, InputsOutputs.DEFAULT_OUTPUT_FILE_NAME)
      }

      extensions.getByType(VisTegPluginExtension).with {
        enabled        = (logging.level ?: gradle.startParameter.logLevel) <= LogLevel.INFO
        colouredNodes  = true
        colouredEdges  = true
        destination    = new File(convention.getPlugin(ProjectConvention).reportsDir, 'visteg.dot')
        exporter       = 'dot'
        colorscheme    = 'paired12'
        nodeShape      = 'box'
        startNodeShape = 'hexagon'
        endNodeShape   = 'doubleoctagon'
      }
    }
  }
}
