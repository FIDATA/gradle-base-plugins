/*
 * org.fidata.project Gradle plugin
 * Copyright Â© 2017  Basil Peace
 *
 * This file is part of gradle-base-plugins.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package org.fidata.gradle;

import static org.gradle.internal.FileUtils.toSafeFileName;
import org.fidata.gradle.internal.AbstractPlugin;
import org.gradle.api.Project;
import org.gradle.initialization.DefaultSettings;
import org.gradle.language.base.plugins.LifecycleBasePlugin;
import nebula.plugin.dependencylock.DependencyLockTaskConfigurer;
import org.ajoberstar.gradle.git.release.base.BaseReleasePlugin;
import org.ajoberstar.gradle.git.publish.GitPublishPlugin;
import org.gradle.api.plugins.ProjectReportsPlugin;
import org.gradle.api.Task;
import nebula.plugin.dependencylock.tasks.GenerateLockTask;
import nebula.plugin.dependencylock.tasks.UpdateLockTask;
import nebula.plugin.dependencylock.tasks.SaveLockTask;
import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask;
import org.gradle.api.tasks.testing.Test;
import org.fidata.gradle.tasks.NoJekyll;
import org.fidata.gradle.tasks.ResignGitCommit;
import org.gradle.api.plugins.quality.CodeNarc;
import org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask;
import org.gradle.api.reporting.components.ComponentReport;
import org.gradle.api.tasks.diagnostics.DependencyReportTask;
import org.gradle.api.tasks.diagnostics.DependencyInsightReportTask;
import org.gradle.api.reporting.dependents.DependentComponentsReport;
import org.gradle.api.reporting.model.ModelReport;
import org.gradle.api.tasks.diagnostics.ProjectReportTask;
import org.gradle.api.tasks.diagnostics.PropertyReportTask;
import org.gradle.api.reporting.dependencies.HtmlDependencyReportTask;
import org.gradle.api.tasks.diagnostics.TaskReportTask;
import org.fidata.gradle.tasks.InputsOutputs;
import org.gradle.api.artifacts.ComponentMetadataDetails;
import org.gradle.api.artifacts.ComponentSelection;
import org.gradle.api.file.FileTreeElement;
import org.checkerframework.checker.nullness.qual.NonNull;
import org.checkerframework.checker.nullness.qual.Nullable;
import com.github.zafarkhaja.semver.Version;
import com.github.zafarkhaja.semver.ParseException;
import groovy.text.StreamingTemplateEngine;
import groovy.text.Template;
import com.google.common.io.Resources;
import com.google.common.base.Charsets;
import org.gradle.api.logging.LogLevel;
import org.fidata.gradle.ProjectPluginDependencies;

/**
 * Provides an environment for a general, language-agnostic project
 */
public final class ProjectPlugin extends AbstractPlugin {
  static final Template COMMIT_MESSAGE_TEMPLATE = new StreamingTemplateEngine().createTemplate(
    '''
      $type: $subject

      Generated by $generatedBy
    '''.stripIndent()
  )

  /**
   * List of filenames considered as license files
   */
  public static final List<String> LICENSE_FILE_NAMES = [
    // These filenames are recognized by JFrog Artifactory
    'license',
    'LICENSE',
    'license.txt',
    'LICENSE.txt',
    'LICENSE.TXT',
    // These are GPL standard file names
    'COPYING',
    'COPYING.LESSER',
  ]

  @Override
  @SuppressWarnings('CouldBeElvis')
  public void apply(Project project) {
    super.apply(project)
    project.with {
      for (String id in ProjectPluginDependencies.DEFAULT_PLUGINS) {
        plugins.apply id
      }

      ProjectConvention projectConvention = new ProjectConvention(project)
      convention.plugins.put 'fidata', projectConvention

      tasks['wrapper'].with {
        group 'Chore'
        gradleVersion = '4.3.1'
      }

      if (!group) { group = 'org.fidata' }

      reporting.baseDir reportsDir
    }

    configureLifecycle()

    configurePrerequisitesLifecycle()

    configureDependencyResolution()

    configureArtifactory()

    configureSigning()

    configureGit()

    configureSemanticRelease()

    configureGitPublish()

    configureCodeNarc()

    configureDiagnostics()

    project.eclipse {
      classpath {
        downloadSources = true
        downloadJavadoc = true
      }
    }
  }

  /**
   * Name of lint task
   */
  public static final String LINT_TASK_NAME = 'lint'

  private void configureLifecycle() {
    project.with {
      tasks[LifecycleBasePlugin.BUILD_TASK_NAME].dependsOn.remove LifecycleBasePlugin.CHECK_TASK_NAME
      tasks[BaseReleasePlugin.RELEASE_TASK_NAME].with {
        // dependsOn LifecycleBasePlugin.BUILD_TASK_NAME TOTEST
        dependsOn tasks[LifecycleBasePlugin.CHECK_TASK_NAME]
        if (isRelease) {
          dependsOn tasks[GitPublishPlugin.PUSH_TASK]
        }
      }
      Task lintTask = task(LINT_TASK_NAME) {
        group 'Verification'
        description 'Runs all static code analyses'
      }
      tasks[LifecycleBasePlugin.CHECK_TASK_NAME].dependsOn lintTask
      tasks.withType(Test) { Test task ->
        task.project.tasks[LifecycleBasePlugin.CHECK_TASK_NAME].dependsOn task
      }
    }
  }

  /**
   * Name of prerequisitesInstall task
   */
  public static final String PREREQUISITES_INSTALL_TASK_NAME = 'prerequisitesInstall'
  /**
   * Name of prerequisitesUpdate task
   */
  public static final String PREREQUISITES_UPDATE_TASK_NAME = 'prerequisitesUpdate'
  /**
   * Name of prerequisitesOutdated task
   */
  public static final String PREREQUISITES_OUTDATED_TASK_NAME = 'prerequisitesOutdated'

  @SuppressWarnings('BracesForForLoop')
  private void configurePrerequisitesLifecycle() {
    project.with {
      Task prerequisitesInstall = task(PREREQUISITES_INSTALL_TASK_NAME) {
        group 'Chore'
        description 'Install all prerequisites for build'
      }
      Task prerequisitesUpdate = task(PREREQUISITES_UPDATE_TASK_NAME) {
        group 'Chore'
        description 'Update all prerequisites that support automatic update'
        mustRunAfter prerequisitesInstall
      }
      Task prerequisitesOutdated = task(PREREQUISITES_OUTDATED_TASK_NAME) {
        group 'Chore'
        description 'Show outdated prerequisites'
        mustRunAfter prerequisitesInstall
      }
      afterEvaluate {
        for (Task task in
          tasks
          - prerequisitesInstall
          - prerequisitesInstall.taskDependencies.getDependencies(prerequisitesInstall)
          - prerequisitesInstall.mustRunAfter.getDependencies(prerequisitesInstall)
          - prerequisitesInstall.shouldRunAfter.getDependencies(prerequisitesInstall)
        ) {
          task.mustRunAfter prerequisitesInstall
        }
        for (Task task in
            tasks
            - prerequisitesUpdate
            - prerequisitesUpdate.taskDependencies.getDependencies(prerequisitesUpdate)
            - prerequisitesUpdate.mustRunAfter.getDependencies(prerequisitesUpdate)
            - prerequisitesUpdate.shouldRunAfter.getDependencies(prerequisitesUpdate)
        ) {
          task.mustRunAfter prerequisitesUpdate
        }
      }

      tasks.withType(GenerateLockTask) { GenerateLockTask task ->
        task.group null
        prerequisitesInstall.mustRunAfter task
      }
      tasks.withType(UpdateLockTask) { UpdateLockTask task ->
        task.group 'Chore'
        prerequisitesUpdate.mustRunAfter task
      }
      tasks.withType(SaveLockTask) { SaveLockTask task ->
        task.group 'Chore'
        prerequisitesUpdate.mustRunAfter task
      }
      tasks['saveGlobalLock']?.with {
        dependsOn tasks[DependencyLockTaskConfigurer.UPDATE_GLOBAL_LOCK_TASK_NAME]
      }
      tasks['saveLock'].with {
        dependsOn tasks[DependencyLockTaskConfigurer.UPDATE_LOCK_TASK_NAME]
      }
      prerequisitesUpdate.with {
        if (tasks['saveGlobalLock']?.outputLock?.exists()) {
          dependsOn tasks['saveGlobalLock']
        }
        else {
          dependsOn tasks['saveLock']
        }
      }

      tasks.withType(DependencyUpdatesTask) { DependencyUpdatesTask task ->
        task.group 'Chore'
        prerequisitesOutdated.dependsOn task
      }
    }
  }

  @NonNull
  static Boolean isPreReleaseVersion(@Nullable String version) {
    if (!version) {
      return null
    }
    try {
      Version.valueOf(version).preReleaseVersion != ''
    }
    catch (ParseException) {
      version.split('[-\\._]').any {
        it = it.toUpperCase()
        it.startsWith('ALPHA') || it.startsWith('BETA') || it.startsWith('RC') || it.startsWith('CR') || it.startsWith('SNAPSHOT')
      }
    }
  }

  private void configureDependencyResolution() {
    project.with {
      dependencyLock.includeTransitives = true

      dependencies.components.all { ComponentMetadataDetails details ->
        if (details.status == 'release') {
          boolean isPreRelease
          try {
            isPreRelease = isPreReleaseVersion(details.id.version)
          }
          catch(Exception) {
            logger.warn sprintf('Error determining whether \'%s\' is pre-release version', [details.id.version])
          }
          if (isPreRelease) {
            details.status = 'milestone'
          }
        }
      }

      dependencyUpdates {
        revision = 'release'
        outputFormatter = 'xml'
        outputDir = new File(xmlReportsDir, 'dependencyUpdates')
        resolutionStrategy = {
          componentSelection.all { ComponentSelection selection ->
            if (revision == 'release') {
              boolean isPreRelease
              try {
                isPreRelease = isPreReleaseVersion(selection.candidate.version)
              }
              catch(Exception) {
                logger.warn sprintf('Error determining whether \'%s\' is pre-release version', [details.id.version])
              }
              if (isPreRelease) {
                selection.reject 'Pre-release version'
              }
            }
          }
        }
      }
    }
  }

  /**
   * URL of FIDATA Artifactory
   */
  public static final String ARTIFACTORY_URL = 'https://fidata.jfrog.io/fidata'

  private void configureArtifactory() {
    project.with {
      if (project.hasProperty('artifactoryUser') && project.hasProperty('artifactoryPassword')) {
        artifactory {
          contextUrl = ARTIFACTORY_URL
          resolve {
            repository {
              repoKey = isRelease ? 'libs-release' : 'libs-snapshot'
              username = project.getProperty('artifactoryUser')
              password = project.getProperty('artifactoryPassword')
              maven = true
            }
          }
        }
      }
      else {
        repositories {
          jcenter()
          mavenCentral()
        }
      }
    }
  }

  private void configureSigning() {
    System.setProperty 'signing.keyId', project.getProperty('gpgKeyId')
    System.setProperty 'signing.password', project.getProperty('gpgKeyPassword')
    System.setProperty 'signing.secretKeyRingFile', project.getProperty('gpgSecretKeyRingFile')
  }

  private void configureGit() {
    if (project.hasProperty('gitUsername') && project.hasProperty('gitPassword')) {
      System.setProperty 'org.ajoberstar.grgit.auth.username', project.getProperty('gitUsername')
      System.setProperty 'org.ajoberstar.grgit.auth.password', project.getProperty('gitPassword')
    }
  }

  private void configureSemanticRelease() {
    if (project.hasProperty('ghToken')) {
      project.semanticRelease.repo.ghToken = project.getProperty('ghToken')
    }
  }

  /**
   * Name of NoJekyll task
   */
  public static final String NO_JEKYLL_TASK_NAME = 'noJekyll'

  private void configureGitPublish() {
    project.with {
      gitPublish {
        branch = 'gh-pages'
        preserve {
          include '**'
          exclude '*-SNAPSHOT/**'
        }
        commitMessage = COMMIT_MESSAGE_TEMPLATE.make(
          type: 'docs',
          subject: "publish documentation for version $version",
          generatedBy: 'org.ajoberstar:gradle-git-publish'
        )
      }

      NoJekyll noJekyllTask = task(NO_JEKYLL_TASK_NAME, type: NoJekyll) {
        description 'Generates .nojekyll file in gitPublish repository'
        destinationDir = gitPublish.repoDir
      }
      tasks[GitPublishPlugin.COMMIT_TASK].dependsOn noJekyllTask

      /*
       * BLOCKED:
       * JGit doesn't support signed commits yet.
       * See https://bugs.eclipse.org/bugs/show_bug.cgi?id=382212 <>
       */
      ResignGitCommit resignGitCommit = task("${ GitPublishPlugin.COMMIT_TASK }Resign", type: ResignGitCommit) {
        description 'Amend git publish commit adding sign to it'
      }
      tasks[GitPublishPlugin.COMMIT_TASK].finalizedBy resignGitCommit
    }
  }

  /**
   * Name of CodeNarc common task
   */
  public static final String CODENARC_TASK_NAME = 'codenarc'

  private static final String CODENARC_DEFAULT_CONFIG = Resources.toString(Resources.getResource(ProjectPlugin, 'config/codenarc/codenarc.groovy'), Charsets.UTF_8)

  private static final Template CODENARC_DISABLED_RULES_CONFIG_TEMPLATE = new StreamingTemplateEngine().createTemplate(Resources.toString(Resources.getResource(ProjectPlugin, 'config/codenarc/codenarc.disabledRules.groovy.template'), Charsets.UTF_8))

  private void configureCodeNarc() {
    project.with {
      Task codeNarcTask = task(CODENARC_TASK_NAME) {
        group 'Verification'
        description 'Runs CodeNarc analysis for each source set'
      }
      tasks[LINT_TASK_NAME].dependsOn codeNarcTask

      tasks.withType(CodeNarc) { CodeNarc task ->
        task.with {
          config = project.resources.text.fromString(CODENARC_DEFAULT_CONFIG)
          doFirst {
            if (task.hasProperty('disabledRules')) {
              config = project.resources.text.fromString(
                config.asString() +
                CODENARC_DISABLED_RULES_CONFIG_TEMPLATE.make(disabledRules: task.getProperty('disabledRules').inspect())
              )
            }
          }
          String reportFileName = "codenarc/${ toSafeFileName((name - ~/^codenarc/).uncapitalize()) }"
          reports {
            xml {
              enabled = true
              destination = new File(project.xmlReportsDir, "${ reportFileName }.xml")
            }
            console.enabled = true
            html {
              enabled = true
              destination = new File(project.htmlReportsDir, "${ reportFileName }.html")
            }
          }
        }
        codeNarcTask.dependsOn task
      }

      task("codenarc${ DefaultSettings.DEFAULT_BUILD_SRC_DIR.capitalize() }", type: CodeNarc) {
        Closure excludeBuildDir = { FileTreeElement fte ->
          String[] p = fte.relativePath.segments
          int i = 0
          while (i < p.length && p[i] == DefaultSettings.DEFAULT_BUILD_SRC_DIR) { i++ }
          i < p.length && p[i] == Project.DEFAULT_BUILD_DIR_NAME
        }
        for (File f in fileTree(projectDir) {
          include '**/*.gradle'
          exclude excludeBuildDir
        }) {
          source f
        }
        for (File f in fileTree(DefaultSettings.DEFAULT_BUILD_SRC_DIR) {
          include '**/*.groovy'
          exclude excludeBuildDir
        }) {
          source f
        }
        source 'Jenkinsfile'
        source fileTree(dir: file('config'), includes: ['**/*.groovy'])
      }
    }
  }

  /**
   * Name of InputsOutputs task
   */
  public static final String INPUTS_OUTPUTS_TASK_NAME = 'inputsOutputs'

  private void configureDiagnostics() {
    project.with {
      projectReportDirName = reportsDir.toPath().relativize(new File(txtReportsDir, 'project').toPath()).toString()

      tasks.withType(BuildEnvironmentReportTask) { BuildEnvironmentReportTask task ->
        task.group 'Diagnostics'
      }
      tasks.withType(ComponentReport) { ComponentReport task ->
        task.group 'Diagnostics'
      }
      tasks.withType(DependencyReportTask) { DependencyReportTask task ->
        task.group 'Diagnostics'
      }
      tasks.withType(DependencyInsightReportTask) { DependencyInsightReportTask task ->
        task.group 'Diagnostics'
      }
      tasks.withType(DependentComponentsReport) { DependentComponentsReport task ->
        task.group 'Diagnostics'
      }
      tasks.withType(ModelReport) { ModelReport task ->
        task.group 'Diagnostics'
      }
      tasks.withType(ProjectReportTask) { ProjectReportTask task ->
        task.group 'Diagnostics'
      }
      tasks.withType(PropertyReportTask) { PropertyReportTask task ->
        task.group 'Diagnostics'
      }
      tasks.withType(HtmlDependencyReportTask) { HtmlDependencyReportTask task ->
        task.group 'Diagnostics'
        reports.html.destination = new File(htmlReportsDir, 'dependencies')
      }
      tasks.withType(TaskReportTask) { TaskReportTask task ->
        task.group 'Diagnostics'
      }
      tasks[ProjectReportsPlugin.PROJECT_REPORT].group 'Diagnostics'

      task(INPUTS_OUTPUTS_TASK_NAME, type: InputsOutputs) {
        group 'Diagnostics'
        description 'Generates report about all task file inputs and outputs'
        outputFile = new File(txtReportsDir, InputsOutputs.DEFAULT_OUTPUT_FILE_NAME)
      }

      visteg {
        enabled        = (logging.level ?: gradle.startParameter.logLevel) <= LogLevel.INFO
        colouredNodes  = true
        colouredEdges  = true
        destination    = new File(reportsDir, 'visteg.dot')
        exporter       = 'dot'
        colorscheme    = 'paired12'
        nodeShape      = 'box'
        startNodeShape = 'hexagon'
        endNodeShape   = 'doubleoctagon'
      }
    }
  }
}
